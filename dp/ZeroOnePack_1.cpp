// 01 背包问题，原始版本，没有优化
// n 个物品
// 总重量是 m
/*
 * 初始化细节
 * 1. 要求“恰好装满背包”时的最优解: 初始化时除了f[0]为0其它f[1..V]均设为-∞。
 * 2. 没有要求必须把背包装满，而是只希望价格尽量大，初始化时应该将f[0..V]全部设为0
 * 为什么呢?
 * 初始化的f数组事实上就是在没有任何物品可以放入背包时的合法状态
 * 1. 要求背包恰好装满.此时只有容量为0的背包可能被价值为0的nothing“恰好装满”，其它容量的背包均没有合法的解，属于未定义的状态，它们的值就都应该是-∞了
 * 2. 如果背包并非必须被装满，那么任何容量的背包都有一个合法解“什么都不装”，这个解的价值为0，所以初始时状态的值也就全部为0了
 * 
 * 
 * 一个常数优化
 * 因为解是最后一个值，即f[v]，而对于f[v]和最后一件要放入的物品n来说，只需要知道f[v-cn]是多少就行；于是，同理，对和物品n-1来说，需要的是。于是，到物品i，也就是物品n-(n-i)，需要的就是。然而，有的物品可能是不会放进去的而且f[-1]是不存在的，于是，max{V-sum{c[i..n]},c[i]}。
 * for i=1..N
    for v=V..0
可以改成
for i=1..n
    bound=max{V-sum{w[i..n]},c[i]}
    for v=V..bound

    尽可能的把物品往体积大的背包里放，那些太小体积的背包，直接可以忽视了。如何确定这个度？
 */

// Deom poj 3624 http://poj.org/problem?id=3624
#include <iostream>
#include <algorithm>
using namespace std;

const int N = 3402 + 1;
const int M = 12880 + 1;
int n, m;
int f[M][M];
int v[N], w[N];

int main()
{
  cin >> n >> m;
  for (int i = 1; i <= n; i++)
    cin >> w[i] >> v[i];
  for (int i = 1; i <= n; i++)
  {
    for (int j = 1; j <= m; j++)
    {
      f[i][j] = f[i - 1][j];
      if (j >= w[i])
      {
        f[i][j] = max(f[i][j], f[i - 1][j - w[i]] + v[i]);
      }
    }
  }
  cout << f[n][m];
  return 0;
}
